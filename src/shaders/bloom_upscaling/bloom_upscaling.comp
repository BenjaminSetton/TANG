
#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform readonly image2D inTexture;
layout(binding = 1, rgba32f) uniform writeonly image2D outTexture;

// Returns a bilinearly-filtered sample at the specified texel position (UV), weighted
// according to the kernel and offset in some direction
vec3 Filter3x3(uvec2 texel, uint[9] kernel, uint kernelWeight)
{
	vec4 result  = imageLoad(inTexture, ivec2(texel + uvec2(-1, -1))) * kernel[0]; // top left
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 0, -1))) * kernel[1]; // top center
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 1, -1))) * kernel[2]; // top right
		 result += imageLoad(inTexture, ivec2(texel + uvec2(-1,  0))) * kernel[3]; // middle left
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 0,  0))) * kernel[4]; // middle center
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 1,  0))) * kernel[5]; // middle right
		 result += imageLoad(inTexture, ivec2(texel + uvec2(-1,  1))) * kernel[6]; // bottom left
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 0,  1))) * kernel[7]; // bottom center
		 result += imageLoad(inTexture, ivec2(texel + uvec2( 1,  1))) * kernel[8]; // bottom right

	return result.rgb / kernelWeight;
}

//
// Bloom implementation based on CoD Advanced Warfare:
// https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/
//
// The general process of this upsampling step is to use a 3x3 tent filter from the input samples to
// achieve the blur, and then write the result of that tent filter blur PLUS a direct sample from
// the input image. This can be summarized as follows, with E being the lowest mip level and A the highest:
// E' = E
// D' = D + blur(E')
// C' = C + blur(D')
// B' = B + blur(C')
// A' = A + blur(B')
//
void main()
{
	uvec2 upper = gl_GlobalInvocationID.xy;
	uvec2 lower = upper >> 1;

	uint[9] kernel;
	kernel[0] = 1; kernel[1] = 2; kernel[2] = 1;
	kernel[3] = 2; kernel[4] = 4; kernel[5] = 2;
	kernel[6] = 1; kernel[7] = 2; kernel[8] = 1;

	//vec3 directSample = imageLoad(inTexture, ivec2(lower)).rgb;
	vec3 filterSample = Filter3x3(lower, kernel, 16);

	imageStore(outTexture, ivec2(upper), vec4(filterSample, 1.0));
}