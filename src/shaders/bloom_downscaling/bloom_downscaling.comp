
#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform readonly image2D inTexture;
layout(binding = 1, rgba32f) uniform writeonly image2D outTexture;

// Returns a bilinearly-filtered sample at the specified texel position (UV), weighted
// according to the kernel and offset in some direction
vec3 BilinearSample(uvec2 uv, vec4 kernel, vec2 offset)
{
	vec2 uvf = vec2(uv);

	vec4 result  = imageLoad(inTexture, ivec2(uvf + vec2(-1.0, -1.0) + offset)) * kernel.x; // top left
	     result += imageLoad(inTexture, ivec2(uvf + vec2( 1.0, -1.0) + offset)) * kernel.y; // top right
	     result += imageLoad(inTexture, ivec2(uvf + vec2(-1.0,  1.0) + offset)) * kernel.z; // bottom left
	     result += imageLoad(inTexture, ivec2(uvf + vec2( 1.0,  1.0) + offset)) * kernel.w; // bottom right
	
	return result.rgb;
}

//
// Bloom implementation based on CoD Advanced Warfare:
// https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/
//
// TODO - Karis Average on the first downsample pass. This is done to reduce firefly artifacts
void main()
{
	uvec2 upper = gl_GlobalInvocationID.xy;
	uvec2 lower = upper >> 1;

	// Specifies the weight for each sample
	vec4 kernel = vec4(0.25);

	// These bilinear samples are weighted according to their offset. The central sample is the most important,
	// receiving a weight of 0.5 while the other 4 samples receive a weight of 0.125
	vec3 sampleAverage  = BilinearSample(upper, kernel, vec2( 0.0,  0.0)) * 0.5  ; // central sample (no offset)
	     sampleAverage += BilinearSample(upper, kernel, vec2(-1.0, -1.0)) * 0.125; // top-left sample
	     sampleAverage += BilinearSample(upper, kernel, vec2( 1.0, -1.0)) * 0.125; // top-right sample
	     sampleAverage += BilinearSample(upper, kernel, vec2(-1.0,  1.0)) * 0.125; // bottom-left sample
		 sampleAverage += BilinearSample(upper, kernel, vec2( 1.0,  1.0)) * 0.125; // bottom-right sample

	imageStore(outTexture, ivec2(lower), vec4(sampleAverage, 1.0));
}